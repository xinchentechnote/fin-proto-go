// Code generated by fin-protoc. DO NOT EDIT.
package bjse_trade_bin

import (
	"bytes"
	"fmt"

	"github.com/xinchentechnote/fin-proto-go/codec"
)

func init() {
	RegistryTradeCaptureConfirmApplIdFactory("031", func() codec.BinaryCodec { return &TradeCaptureConfirmExtend031{} })
	RegistryTradeCaptureConfirmApplIdFactory("051", func() codec.BinaryCodec { return &TradeCaptureConfirmExtend051{} })
	RegistryTradeCaptureConfirmApplIdFactory("060", func() codec.BinaryCodec { return &TradeCaptureConfirmExtend060{} })
	RegistryTradeCaptureConfirmApplIdFactory("061", func() codec.BinaryCodec { return &TradeCaptureConfirmExtend061{} })
	RegistryTradeCaptureConfirmApplIdFactory("062", func() codec.BinaryCodec { return &TradeCaptureConfirmExtend062{} })
}

var tradeCaptureConfirmApplIdFactoryCache = map[string]func() codec.BinaryCodec{}

func RegistryTradeCaptureConfirmApplIdFactory(applId string, factory func() codec.BinaryCodec) {
	tradeCaptureConfirmApplIdFactoryCache[applId] = factory
}

func NewTradeCaptureConfirmMessageByApplId(key string) (codec.BinaryCodec, error) {
	if factory, ok := tradeCaptureConfirmApplIdFactoryCache[key]; ok {
		return factory(), nil
	}
	return nil, fmt.Errorf("unknown message type")
}

// TradeCaptureConfirm represents the packet structure.
type TradeCaptureConfirm struct {
	PartitionNo           int32             `json:"PartitionNo"`
	ReportIndex           int64             `json:"ReportIndex"`
	ApplId                string            `json:"ApplID"`
	ReportingPbuid        string            `json:"ReportingPBUID"`
	SubmittingPbuid       string            `json:"SubmittingPBUID"`
	SecurityId            string            `json:"SecurityID"`
	SecurityIdsource      string            `json:"SecurityIDSource"`
	OwnerType             uint16            `json:"OwnerType"`
	ClearingFirm          string            `json:"ClearingFirm"`
	TransactTime          int64             `json:"TransactTime"`
	UserInfo              string            `json:"UserInfo"`
	TradeId               string            `json:"TradeID"`
	TradeReportId         string            `json:"TradeReportID"`
	TradeReportType       uint8             `json:"TradeReportType"`
	TradeReportTransType  uint8             `json:"TradeReportTransType"`
	TradeHandlingInstr    string            `json:"TradeHandlingInstr"`
	LastPx                int64             `json:"LastPx"`
	LastQty               int64             `json:"LastQty"`
	TrdType               uint16            `json:"TrdType"`
	TrdSubType            uint16            `json:"TrdSubType"`
	ConfirmId             uint32            `json:"ConfirmID"`
	ExecId                string            `json:"ExecID"`
	Side                  string            `json:"Side"`
	Pbuid                 string            `json:"PBUID"`
	AccountId             string            `json:"AccountID"`
	BranchId              string            `json:"BranchID"`
	CounterPartyPbuid     string            `json:"CounterPartyPBUID"`
	CounterPartyAccountId string            `json:"CounterPartyAccountID"`
	CounterPartyBranchId  string            `json:"CounterPartyBranchID"`
	ApplExtend            codec.BinaryCodec `json:"ApplExtend"`
}

// NewTradeCaptureConfirm creates a new instance of TradeCaptureConfirm.
func NewTradeCaptureConfirm() *TradeCaptureConfirm {
	return &TradeCaptureConfirm{}
}

// String returns a string representation of the packet.
func (p *TradeCaptureConfirm) String() string {
	return fmt.Sprintf("TradeCaptureConfirm{PartitionNo: %v, ReportIndex: %v, ApplId: %v, ReportingPbuid: %v, SubmittingPbuid: %v, SecurityId: %v, SecurityIdsource: %v, OwnerType: %v, ClearingFirm: %v, TransactTime: %v, UserInfo: %v, TradeId: %v, TradeReportId: %v, TradeReportType: %v, TradeReportTransType: %v, TradeHandlingInstr: %v, LastPx: %v, LastQty: %v, TrdType: %v, TrdSubType: %v, ConfirmId: %v, ExecId: %v, Side: %v, Pbuid: %v, AccountId: %v, BranchId: %v, CounterPartyPbuid: %v, CounterPartyAccountId: %v, CounterPartyBranchId: %v, ApplExtend: %v}", p.PartitionNo, p.ReportIndex, p.ApplId, p.ReportingPbuid, p.SubmittingPbuid, p.SecurityId, p.SecurityIdsource, p.OwnerType, p.ClearingFirm, p.TransactTime, p.UserInfo, p.TradeId, p.TradeReportId, p.TradeReportType, p.TradeReportTransType, p.TradeHandlingInstr, p.LastPx, p.LastQty, p.TrdType, p.TrdSubType, p.ConfirmId, p.ExecId, p.Side, p.Pbuid, p.AccountId, p.BranchId, p.CounterPartyPbuid, p.CounterPartyAccountId, p.CounterPartyBranchId, p.ApplExtend)
}

// Encode encodes the packet into a byte slice.
func (p *TradeCaptureConfirm) Encode(buf *bytes.Buffer) error {
	// Implement encoding logic here.
	if err := codec.WriteBasicTypeLE(buf, p.PartitionNo); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "PartitionNo", err)
	}
	if err := codec.WriteBasicTypeLE(buf, p.ReportIndex); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "ReportIndex", err)
	}
	if err := codec.WriteFixedString(buf, p.ApplId, 3); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.ReportingPbuid, 6); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.SubmittingPbuid, 6); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.SecurityId, 8); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.SecurityIdsource, 4); err != nil {
		return err
	}
	if err := codec.WriteBasicTypeLE(buf, p.OwnerType); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "OwnerType", err)
	}
	if err := codec.WriteFixedString(buf, p.ClearingFirm, 2); err != nil {
		return err
	}
	if err := codec.WriteBasicTypeLE(buf, p.TransactTime); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "TransactTime", err)
	}
	if err := codec.WriteFixedString(buf, p.UserInfo, 32); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.TradeId, 16); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.TradeReportId, 10); err != nil {
		return err
	}
	if err := codec.WriteBasicTypeLE(buf, p.TradeReportType); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "TradeReportType", err)
	}
	if err := codec.WriteBasicTypeLE(buf, p.TradeReportTransType); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "TradeReportTransType", err)
	}
	if err := codec.WriteFixedString(buf, p.TradeHandlingInstr, 1); err != nil {
		return err
	}
	if err := codec.WriteBasicTypeLE(buf, p.LastPx); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "LastPx", err)
	}
	if err := codec.WriteBasicTypeLE(buf, p.LastQty); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "LastQty", err)
	}
	if err := codec.WriteBasicTypeLE(buf, p.TrdType); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "TrdType", err)
	}
	if err := codec.WriteBasicTypeLE(buf, p.TrdSubType); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "TrdSubType", err)
	}
	if err := codec.WriteBasicTypeLE(buf, p.ConfirmId); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "ConfirmID", err)
	}
	if err := codec.WriteFixedString(buf, p.ExecId, 16); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.Side, 1); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.Pbuid, 6); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.AccountId, 10); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.BranchId, 2); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.CounterPartyPbuid, 6); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.CounterPartyAccountId, 10); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.CounterPartyBranchId, 2); err != nil {
		return err
	}
	if p.ApplExtend == nil {
		if val, err := NewTradeCaptureConfirmMessageByApplId(p.ApplId); err != nil {
			return err
		} else {
			p.ApplExtend = val
		}
	}
	if err := p.ApplExtend.Encode(buf); err != nil {
		return err
	}
	return nil
}

// Decode decodes the packet from a byte slice.
func (p *TradeCaptureConfirm) Decode(buf *bytes.Buffer) error {
	if val, err := codec.ReadBasicTypeLE[int32](buf); err != nil {
		return err
	} else {
		p.PartitionNo = val
	}
	if val, err := codec.ReadBasicTypeLE[int64](buf); err != nil {
		return err
	} else {
		p.ReportIndex = val
	}
	if val, err := codec.ReadFixedString(buf, 3); err != nil {
		return err
	} else {
		p.ApplId = val
	}
	if val, err := codec.ReadFixedString(buf, 6); err != nil {
		return err
	} else {
		p.ReportingPbuid = val
	}
	if val, err := codec.ReadFixedString(buf, 6); err != nil {
		return err
	} else {
		p.SubmittingPbuid = val
	}
	if val, err := codec.ReadFixedString(buf, 8); err != nil {
		return err
	} else {
		p.SecurityId = val
	}
	if val, err := codec.ReadFixedString(buf, 4); err != nil {
		return err
	} else {
		p.SecurityIdsource = val
	}
	if val, err := codec.ReadBasicTypeLE[uint16](buf); err != nil {
		return err
	} else {
		p.OwnerType = val
	}
	if val, err := codec.ReadFixedString(buf, 2); err != nil {
		return err
	} else {
		p.ClearingFirm = val
	}
	if val, err := codec.ReadBasicTypeLE[int64](buf); err != nil {
		return err
	} else {
		p.TransactTime = val
	}
	if val, err := codec.ReadFixedString(buf, 32); err != nil {
		return err
	} else {
		p.UserInfo = val
	}
	if val, err := codec.ReadFixedString(buf, 16); err != nil {
		return err
	} else {
		p.TradeId = val
	}
	if val, err := codec.ReadFixedString(buf, 10); err != nil {
		return err
	} else {
		p.TradeReportId = val
	}
	if val, err := codec.ReadBasicTypeLE[uint8](buf); err != nil {
		return err
	} else {
		p.TradeReportType = val
	}
	if val, err := codec.ReadBasicTypeLE[uint8](buf); err != nil {
		return err
	} else {
		p.TradeReportTransType = val
	}
	if val, err := codec.ReadFixedString(buf, 1); err != nil {
		return err
	} else {
		p.TradeHandlingInstr = val
	}
	if val, err := codec.ReadBasicTypeLE[int64](buf); err != nil {
		return err
	} else {
		p.LastPx = val
	}
	if val, err := codec.ReadBasicTypeLE[int64](buf); err != nil {
		return err
	} else {
		p.LastQty = val
	}
	if val, err := codec.ReadBasicTypeLE[uint16](buf); err != nil {
		return err
	} else {
		p.TrdType = val
	}
	if val, err := codec.ReadBasicTypeLE[uint16](buf); err != nil {
		return err
	} else {
		p.TrdSubType = val
	}
	if val, err := codec.ReadBasicTypeLE[uint32](buf); err != nil {
		return err
	} else {
		p.ConfirmId = val
	}
	if val, err := codec.ReadFixedString(buf, 16); err != nil {
		return err
	} else {
		p.ExecId = val
	}
	if val, err := codec.ReadFixedString(buf, 1); err != nil {
		return err
	} else {
		p.Side = val
	}
	if val, err := codec.ReadFixedString(buf, 6); err != nil {
		return err
	} else {
		p.Pbuid = val
	}
	if val, err := codec.ReadFixedString(buf, 10); err != nil {
		return err
	} else {
		p.AccountId = val
	}
	if val, err := codec.ReadFixedString(buf, 2); err != nil {
		return err
	} else {
		p.BranchId = val
	}
	if val, err := codec.ReadFixedString(buf, 6); err != nil {
		return err
	} else {
		p.CounterPartyPbuid = val
	}
	if val, err := codec.ReadFixedString(buf, 10); err != nil {
		return err
	} else {
		p.CounterPartyAccountId = val
	}
	if val, err := codec.ReadFixedString(buf, 2); err != nil {
		return err
	} else {
		p.CounterPartyBranchId = val
	}
	if val, err := NewTradeCaptureConfirmMessageByApplId(p.ApplId); err != nil {
		return err
	} else {
		p.ApplExtend = val
	}
	if err := p.ApplExtend.Decode(buf); err != nil {
		return err
	}
	return nil
}
