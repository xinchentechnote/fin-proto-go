// Code generated by fin-protoc. DO NOT EDIT.
package bjse_trade_bin

import (
	"bytes"
	"fmt"

	"github.com/xinchentechnote/fin-proto-go/codec"
)

func init() {
	RegistryTradeCaptureReportApplIdFactory("031", func() codec.BinaryCodec { return &TradeCaptureReportExtend031{} })
	RegistryTradeCaptureReportApplIdFactory("051", func() codec.BinaryCodec { return &TradeCaptureReportExtend051{} })
	RegistryTradeCaptureReportApplIdFactory("060", func() codec.BinaryCodec { return &TradeCaptureReportExtend060{} })
	RegistryTradeCaptureReportApplIdFactory("061", func() codec.BinaryCodec { return &TradeCaptureReportExtend061{} })
	RegistryTradeCaptureReportApplIdFactory("062", func() codec.BinaryCodec { return &TradeCaptureReportExtend062{} })
}

var tradeCaptureReportApplIdFactoryCache = map[string]func() codec.BinaryCodec{}

func RegistryTradeCaptureReportApplIdFactory(applId string, factory func() codec.BinaryCodec) {
	tradeCaptureReportApplIdFactoryCache[applId] = factory
}

func NewTradeCaptureReportMessageByApplId(key string) (codec.BinaryCodec, error) {
	if factory, ok := tradeCaptureReportApplIdFactoryCache[key]; ok {
		return factory(), nil
	}
	return nil, fmt.Errorf("unknown message type")
}

// TradeCaptureReport represents the packet structure.
type TradeCaptureReport struct {
	ApplId                string            `json:"ApplID"`
	SubmittingPbuid       string            `json:"SubmittingPBUID"`
	SecurityId            string            `json:"SecurityID"`
	SecurityIdsource      string            `json:"SecurityIDSource"`
	OwnerType             uint16            `json:"OwnerType"`
	ClearingFirm          string            `json:"ClearingFirm"`
	TransactTime          int64             `json:"TransactTime"`
	UserInfo              string            `json:"UserInfo"`
	TradeReportId         string            `json:"TradeReportID"`
	TradeReportType       uint8             `json:"TradeReportType"`
	TradeReportTransType  uint8             `json:"TradeReportTransType"`
	TradeHandlingInstr    string            `json:"TradeHandlingInstr"`
	TradeReportRefId      string            `json:"TradeReportRefID"`
	LastPx                int64             `json:"LastPx"`
	LastQty               int64             `json:"LastQty"`
	TrdType               uint16            `json:"TrdType"`
	TrdSubType            uint16            `json:"TrdSubType"`
	ConfirmId             uint32            `json:"ConfirmID"`
	Side                  string            `json:"Side"`
	Pbuid                 string            `json:"PBUID"`
	AccountId             string            `json:"AccountID"`
	BranchId              string            `json:"BranchID"`
	CounterPartyPbuid     string            `json:"CounterPartyPBUID"`
	CounterPartyAccountId string            `json:"CounterPartyAccountID"`
	CounterPartyBranchId  string            `json:"CounterPartyBranchID"`
	ApplExtend            codec.BinaryCodec `json:"ApplExtend"`
}

// NewTradeCaptureReport creates a new instance of TradeCaptureReport.
func NewTradeCaptureReport() *TradeCaptureReport {
	return &TradeCaptureReport{}
}

// String returns a string representation of the packet.
func (p *TradeCaptureReport) String() string {
	return fmt.Sprintf("TradeCaptureReport{ApplId: %v, SubmittingPbuid: %v, SecurityId: %v, SecurityIdsource: %v, OwnerType: %v, ClearingFirm: %v, TransactTime: %v, UserInfo: %v, TradeReportId: %v, TradeReportType: %v, TradeReportTransType: %v, TradeHandlingInstr: %v, TradeReportRefId: %v, LastPx: %v, LastQty: %v, TrdType: %v, TrdSubType: %v, ConfirmId: %v, Side: %v, Pbuid: %v, AccountId: %v, BranchId: %v, CounterPartyPbuid: %v, CounterPartyAccountId: %v, CounterPartyBranchId: %v, ApplExtend: %v}", p.ApplId, p.SubmittingPbuid, p.SecurityId, p.SecurityIdsource, p.OwnerType, p.ClearingFirm, p.TransactTime, p.UserInfo, p.TradeReportId, p.TradeReportType, p.TradeReportTransType, p.TradeHandlingInstr, p.TradeReportRefId, p.LastPx, p.LastQty, p.TrdType, p.TrdSubType, p.ConfirmId, p.Side, p.Pbuid, p.AccountId, p.BranchId, p.CounterPartyPbuid, p.CounterPartyAccountId, p.CounterPartyBranchId, p.ApplExtend)
}

// Encode encodes the packet into a byte slice.
func (p *TradeCaptureReport) Encode(buf *bytes.Buffer) error {
	// Implement encoding logic here.
	if err := codec.WriteFixedString(buf, p.ApplId, 3); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.SubmittingPbuid, 6); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.SecurityId, 8); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.SecurityIdsource, 4); err != nil {
		return err
	}
	if err := codec.WriteBasicTypeLE(buf, p.OwnerType); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "OwnerType", err)
	}
	if err := codec.WriteFixedString(buf, p.ClearingFirm, 2); err != nil {
		return err
	}
	if err := codec.WriteBasicTypeLE(buf, p.TransactTime); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "TransactTime", err)
	}
	if err := codec.WriteFixedString(buf, p.UserInfo, 32); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.TradeReportId, 10); err != nil {
		return err
	}
	if err := codec.WriteBasicTypeLE(buf, p.TradeReportType); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "TradeReportType", err)
	}
	if err := codec.WriteBasicTypeLE(buf, p.TradeReportTransType); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "TradeReportTransType", err)
	}
	if err := codec.WriteFixedString(buf, p.TradeHandlingInstr, 1); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.TradeReportRefId, 10); err != nil {
		return err
	}
	if err := codec.WriteBasicTypeLE(buf, p.LastPx); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "LastPx", err)
	}
	if err := codec.WriteBasicTypeLE(buf, p.LastQty); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "LastQty", err)
	}
	if err := codec.WriteBasicTypeLE(buf, p.TrdType); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "TrdType", err)
	}
	if err := codec.WriteBasicTypeLE(buf, p.TrdSubType); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "TrdSubType", err)
	}
	if err := codec.WriteBasicTypeLE(buf, p.ConfirmId); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "ConfirmID", err)
	}
	if err := codec.WriteFixedString(buf, p.Side, 1); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.Pbuid, 6); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.AccountId, 10); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.BranchId, 2); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.CounterPartyPbuid, 6); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.CounterPartyAccountId, 10); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.CounterPartyBranchId, 2); err != nil {
		return err
	}
	if p.ApplExtend == nil {
		if val, err := NewTradeCaptureReportMessageByApplId(p.ApplId); err != nil {
			return err
		} else {
			p.ApplExtend = val
		}
	}
	if err := p.ApplExtend.Encode(buf); err != nil {
		return err
	}
	return nil
}

// Decode decodes the packet from a byte slice.
func (p *TradeCaptureReport) Decode(buf *bytes.Buffer) error {
	if val, err := codec.ReadFixedString(buf, 3); err != nil {
		return err
	} else {
		p.ApplId = val
	}
	if val, err := codec.ReadFixedString(buf, 6); err != nil {
		return err
	} else {
		p.SubmittingPbuid = val
	}
	if val, err := codec.ReadFixedString(buf, 8); err != nil {
		return err
	} else {
		p.SecurityId = val
	}
	if val, err := codec.ReadFixedString(buf, 4); err != nil {
		return err
	} else {
		p.SecurityIdsource = val
	}
	if val, err := codec.ReadBasicTypeLE[uint16](buf); err != nil {
		return err
	} else {
		p.OwnerType = val
	}
	if val, err := codec.ReadFixedString(buf, 2); err != nil {
		return err
	} else {
		p.ClearingFirm = val
	}
	if val, err := codec.ReadBasicTypeLE[int64](buf); err != nil {
		return err
	} else {
		p.TransactTime = val
	}
	if val, err := codec.ReadFixedString(buf, 32); err != nil {
		return err
	} else {
		p.UserInfo = val
	}
	if val, err := codec.ReadFixedString(buf, 10); err != nil {
		return err
	} else {
		p.TradeReportId = val
	}
	if val, err := codec.ReadBasicTypeLE[uint8](buf); err != nil {
		return err
	} else {
		p.TradeReportType = val
	}
	if val, err := codec.ReadBasicTypeLE[uint8](buf); err != nil {
		return err
	} else {
		p.TradeReportTransType = val
	}
	if val, err := codec.ReadFixedString(buf, 1); err != nil {
		return err
	} else {
		p.TradeHandlingInstr = val
	}
	if val, err := codec.ReadFixedString(buf, 10); err != nil {
		return err
	} else {
		p.TradeReportRefId = val
	}
	if val, err := codec.ReadBasicTypeLE[int64](buf); err != nil {
		return err
	} else {
		p.LastPx = val
	}
	if val, err := codec.ReadBasicTypeLE[int64](buf); err != nil {
		return err
	} else {
		p.LastQty = val
	}
	if val, err := codec.ReadBasicTypeLE[uint16](buf); err != nil {
		return err
	} else {
		p.TrdType = val
	}
	if val, err := codec.ReadBasicTypeLE[uint16](buf); err != nil {
		return err
	} else {
		p.TrdSubType = val
	}
	if val, err := codec.ReadBasicTypeLE[uint32](buf); err != nil {
		return err
	} else {
		p.ConfirmId = val
	}
	if val, err := codec.ReadFixedString(buf, 1); err != nil {
		return err
	} else {
		p.Side = val
	}
	if val, err := codec.ReadFixedString(buf, 6); err != nil {
		return err
	} else {
		p.Pbuid = val
	}
	if val, err := codec.ReadFixedString(buf, 10); err != nil {
		return err
	} else {
		p.AccountId = val
	}
	if val, err := codec.ReadFixedString(buf, 2); err != nil {
		return err
	} else {
		p.BranchId = val
	}
	if val, err := codec.ReadFixedString(buf, 6); err != nil {
		return err
	} else {
		p.CounterPartyPbuid = val
	}
	if val, err := codec.ReadFixedString(buf, 10); err != nil {
		return err
	} else {
		p.CounterPartyAccountId = val
	}
	if val, err := codec.ReadFixedString(buf, 2); err != nil {
		return err
	} else {
		p.CounterPartyBranchId = val
	}
	if val, err := NewTradeCaptureReportMessageByApplId(p.ApplId); err != nil {
		return err
	} else {
		p.ApplExtend = val
	}
	if err := p.ApplExtend.Decode(buf); err != nil {
		return err
	}
	return nil
}
