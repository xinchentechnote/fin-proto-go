// Code generated by fin-protoc. DO NOT EDIT.
package sse_bin

import (
	"bytes"
	"fmt"

	"github.com/xinchentechnote/fin-proto-go/codec"
)

func init() {
}

// OrderCancel represents the packet structure.
type OrderCancel struct {
	BizId        uint32 `json:"BizID"`
	BizPbu       string `json:"BizPbu"`
	ClOrdId      string `json:"ClOrdID"`
	SecurityId   string `json:"SecurityID"`
	Account      string `json:"Account"`
	OwnerType    uint8  `json:"OwnerType"`
	Side         string `json:"Side"`
	OrigClOrdId  string `json:"OrigClOrdID"`
	TransactTime uint64 `json:"TransactTime"`
	BranchId     string `json:"BranchID"`
	UserInfo     string `json:"UserInfo"`
}

// NewOrderCancel creates a new instance of OrderCancel.
func NewOrderCancel() *OrderCancel {
	return &OrderCancel{}
}

// String returns a string representation of the packet.
func (p *OrderCancel) String() string {
	return fmt.Sprintf("OrderCancel{BizId: %v, BizPbu: %v, ClOrdId: %v, SecurityId: %v, Account: %v, OwnerType: %v, Side: %v, OrigClOrdId: %v, TransactTime: %v, BranchId: %v, UserInfo: %v}", p.BizId, p.BizPbu, p.ClOrdId, p.SecurityId, p.Account, p.OwnerType, p.Side, p.OrigClOrdId, p.TransactTime, p.BranchId, p.UserInfo)
}

// Encode encodes the packet into a byte slice.
func (p *OrderCancel) Encode(buf *bytes.Buffer) error {
	// Implement encoding logic here.
	if err := codec.PutBasicType(buf, p.BizId); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "BizID", err)
	}
	if err := codec.PutFixedString(buf, p.BizPbu, 8); err != nil {
		return err
	}
	if err := codec.PutFixedString(buf, p.ClOrdId, 10); err != nil {
		return err
	}
	if err := codec.PutFixedString(buf, p.SecurityId, 12); err != nil {
		return err
	}
	if err := codec.PutFixedString(buf, p.Account, 13); err != nil {
		return err
	}
	if err := codec.PutBasicType(buf, p.OwnerType); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "OwnerType", err)
	}
	if err := codec.PutFixedString(buf, p.Side, 1); err != nil {
		return err
	}
	if err := codec.PutFixedString(buf, p.OrigClOrdId, 10); err != nil {
		return err
	}
	if err := codec.PutBasicType(buf, p.TransactTime); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "TransactTime", err)
	}
	if err := codec.PutFixedString(buf, p.BranchId, 8); err != nil {
		return err
	}
	if err := codec.PutFixedString(buf, p.UserInfo, 32); err != nil {
		return err
	}
	return nil
}

// Decode decodes the packet from a byte slice.
func (p *OrderCancel) Decode(buf *bytes.Buffer) error {
	if val, err := codec.GetBasicType[uint32](buf); err != nil {
		return err
	} else {
		p.BizId = val
	}
	if val, err := codec.GetFixedString(buf, 8); err != nil {
		return err
	} else {
		p.BizPbu = val
	}
	if val, err := codec.GetFixedString(buf, 10); err != nil {
		return err
	} else {
		p.ClOrdId = val
	}
	if val, err := codec.GetFixedString(buf, 12); err != nil {
		return err
	} else {
		p.SecurityId = val
	}
	if val, err := codec.GetFixedString(buf, 13); err != nil {
		return err
	} else {
		p.Account = val
	}
	if val, err := codec.GetBasicType[uint8](buf); err != nil {
		return err
	} else {
		p.OwnerType = val
	}
	if val, err := codec.GetFixedString(buf, 1); err != nil {
		return err
	} else {
		p.Side = val
	}
	if val, err := codec.GetFixedString(buf, 10); err != nil {
		return err
	} else {
		p.OrigClOrdId = val
	}
	if val, err := codec.GetBasicType[uint64](buf); err != nil {
		return err
	} else {
		p.TransactTime = val
	}
	if val, err := codec.GetFixedString(buf, 8); err != nil {
		return err
	} else {
		p.BranchId = val
	}
	if val, err := codec.GetFixedString(buf, 32); err != nil {
		return err
	} else {
		p.UserInfo = val
	}
	return nil
}
