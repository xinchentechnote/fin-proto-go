// Code generated by fin-protoc. DO NOT EDIT.
package sse_bin

import (
	"bytes"
	"fmt"

	"github.com/xinchentechnote/fin-proto-go/codec"
)

func init() {
}

// Report represents the packet structure.
type Report struct {
	Pbu            string `json:"Pbu"`
	SetId          uint32 `json:"SetID"`
	ReportIndex    uint64 `json:"ReportIndex"`
	BizId          uint32 `json:"BizID"`
	ExecType       string `json:"ExecType"`
	BizPbu         string `json:"BizPbu"`
	ClOrdId        string `json:"ClOrdID"`
	SecurityId     string `json:"SecurityID"`
	Account        string `json:"Account"`
	OwnerType      uint8  `json:"OwnerType"`
	OrderEntryTime uint64 `json:"OrderEntryTime"`
	LastPx         int64  `json:"LastPx"`
	LastQty        int64  `json:"LastQty"`
	GrossTradeAmt  int64  `json:"GrossTradeAmt"`
	Side           string `json:"Side"`
	OrderQty       int64  `json:"OrderQty"`
	LeavesQty      int64  `json:"LeavesQty"`
	OrdStatus      string `json:"OrdStatus"`
	CreditTag      string `json:"CreditTag"`
	ClearingFirm   string `json:"ClearingFirm"`
	BranchId       string `json:"BranchID"`
	TrdCnfmId      string `json:"TrdCnfmID"`
	OrdCnfmId      string `json:"OrdCnfmID"`
	TradeDate      uint32 `json:"TradeDate"`
	TransactTime   uint64 `json:"TransactTime"`
	UserInfo       string `json:"UserInfo"`
}

// NewReport creates a new instance of Report.
func NewReport() *Report {
	return &Report{}
}

// String returns a string representation of the packet.
func (p *Report) String() string {
	return fmt.Sprintf("Report{Pbu: %v, SetId: %v, ReportIndex: %v, BizId: %v, ExecType: %v, BizPbu: %v, ClOrdId: %v, SecurityId: %v, Account: %v, OwnerType: %v, OrderEntryTime: %v, LastPx: %v, LastQty: %v, GrossTradeAmt: %v, Side: %v, OrderQty: %v, LeavesQty: %v, OrdStatus: %v, CreditTag: %v, ClearingFirm: %v, BranchId: %v, TrdCnfmId: %v, OrdCnfmId: %v, TradeDate: %v, TransactTime: %v, UserInfo: %v}", p.Pbu, p.SetId, p.ReportIndex, p.BizId, p.ExecType, p.BizPbu, p.ClOrdId, p.SecurityId, p.Account, p.OwnerType, p.OrderEntryTime, p.LastPx, p.LastQty, p.GrossTradeAmt, p.Side, p.OrderQty, p.LeavesQty, p.OrdStatus, p.CreditTag, p.ClearingFirm, p.BranchId, p.TrdCnfmId, p.OrdCnfmId, p.TradeDate, p.TransactTime, p.UserInfo)
}

// Encode encodes the packet into a byte slice.
func (p *Report) Encode(buf *bytes.Buffer) error {
	// Implement encoding logic here.
	if err := codec.WriteFixedString(buf, p.Pbu, 8); err != nil {
		return err
	}
	if err := codec.WriteBasicType(buf, p.SetId); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "SetID", err)
	}
	if err := codec.WriteBasicType(buf, p.ReportIndex); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "ReportIndex", err)
	}
	if err := codec.WriteBasicType(buf, p.BizId); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "BizID", err)
	}
	if err := codec.WriteFixedString(buf, p.ExecType, 1); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.BizPbu, 8); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.ClOrdId, 10); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.SecurityId, 12); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.Account, 13); err != nil {
		return err
	}
	if err := codec.WriteBasicType(buf, p.OwnerType); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "OwnerType", err)
	}
	if err := codec.WriteBasicType(buf, p.OrderEntryTime); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "OrderEntryTime", err)
	}
	if err := codec.WriteBasicType(buf, p.LastPx); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "LastPx", err)
	}
	if err := codec.WriteBasicType(buf, p.LastQty); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "LastQty", err)
	}
	if err := codec.WriteBasicType(buf, p.GrossTradeAmt); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "GrossTradeAmt", err)
	}
	if err := codec.WriteFixedString(buf, p.Side, 1); err != nil {
		return err
	}
	if err := codec.WriteBasicType(buf, p.OrderQty); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "OrderQty", err)
	}
	if err := codec.WriteBasicType(buf, p.LeavesQty); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "LeavesQty", err)
	}
	if err := codec.WriteFixedString(buf, p.OrdStatus, 1); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.CreditTag, 2); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.ClearingFirm, 8); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.BranchId, 8); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.TrdCnfmId, 16); err != nil {
		return err
	}
	if err := codec.WriteFixedString(buf, p.OrdCnfmId, 16); err != nil {
		return err
	}
	if err := codec.WriteBasicType(buf, p.TradeDate); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "TradeDate", err)
	}
	if err := codec.WriteBasicType(buf, p.TransactTime); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "TransactTime", err)
	}
	if err := codec.WriteFixedString(buf, p.UserInfo, 32); err != nil {
		return err
	}
	return nil
}

// Decode decodes the packet from a byte slice.
func (p *Report) Decode(buf *bytes.Buffer) error {
	if val, err := codec.ReadFixedString(buf, 8); err != nil {
		return err
	} else {
		p.Pbu = val
	}
	if val, err := codec.ReadBasicType[uint32](buf); err != nil {
		return err
	} else {
		p.SetId = val
	}
	if val, err := codec.ReadBasicType[uint64](buf); err != nil {
		return err
	} else {
		p.ReportIndex = val
	}
	if val, err := codec.ReadBasicType[uint32](buf); err != nil {
		return err
	} else {
		p.BizId = val
	}
	if val, err := codec.ReadFixedString(buf, 1); err != nil {
		return err
	} else {
		p.ExecType = val
	}
	if val, err := codec.ReadFixedString(buf, 8); err != nil {
		return err
	} else {
		p.BizPbu = val
	}
	if val, err := codec.ReadFixedString(buf, 10); err != nil {
		return err
	} else {
		p.ClOrdId = val
	}
	if val, err := codec.ReadFixedString(buf, 12); err != nil {
		return err
	} else {
		p.SecurityId = val
	}
	if val, err := codec.ReadFixedString(buf, 13); err != nil {
		return err
	} else {
		p.Account = val
	}
	if val, err := codec.ReadBasicType[uint8](buf); err != nil {
		return err
	} else {
		p.OwnerType = val
	}
	if val, err := codec.ReadBasicType[uint64](buf); err != nil {
		return err
	} else {
		p.OrderEntryTime = val
	}
	if val, err := codec.ReadBasicType[int64](buf); err != nil {
		return err
	} else {
		p.LastPx = val
	}
	if val, err := codec.ReadBasicType[int64](buf); err != nil {
		return err
	} else {
		p.LastQty = val
	}
	if val, err := codec.ReadBasicType[int64](buf); err != nil {
		return err
	} else {
		p.GrossTradeAmt = val
	}
	if val, err := codec.ReadFixedString(buf, 1); err != nil {
		return err
	} else {
		p.Side = val
	}
	if val, err := codec.ReadBasicType[int64](buf); err != nil {
		return err
	} else {
		p.OrderQty = val
	}
	if val, err := codec.ReadBasicType[int64](buf); err != nil {
		return err
	} else {
		p.LeavesQty = val
	}
	if val, err := codec.ReadFixedString(buf, 1); err != nil {
		return err
	} else {
		p.OrdStatus = val
	}
	if val, err := codec.ReadFixedString(buf, 2); err != nil {
		return err
	} else {
		p.CreditTag = val
	}
	if val, err := codec.ReadFixedString(buf, 8); err != nil {
		return err
	} else {
		p.ClearingFirm = val
	}
	if val, err := codec.ReadFixedString(buf, 8); err != nil {
		return err
	} else {
		p.BranchId = val
	}
	if val, err := codec.ReadFixedString(buf, 16); err != nil {
		return err
	} else {
		p.TrdCnfmId = val
	}
	if val, err := codec.ReadFixedString(buf, 16); err != nil {
		return err
	} else {
		p.OrdCnfmId = val
	}
	if val, err := codec.ReadBasicType[uint32](buf); err != nil {
		return err
	} else {
		p.TradeDate = val
	}
	if val, err := codec.ReadBasicType[uint64](buf); err != nil {
		return err
	} else {
		p.TransactTime = val
	}
	if val, err := codec.ReadFixedString(buf, 32); err != nil {
		return err
	} else {
		p.UserInfo = val
	}
	return nil
}
