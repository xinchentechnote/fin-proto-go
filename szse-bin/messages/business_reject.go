// Code generated by fin-protoc. DO NOT EDIT.
package szse_bin

import (
	"bytes"
	"fmt"

	"github.com/xinchentechnote/fin-proto-go/codec"
)

func init() {
}

// BusinessReject represents the packet structure.
type BusinessReject struct {
	ApplId               string `json:"ApplID"`
	TransactTime         int64  `json:"TransactTime"`
	SubmittingPbuid      string `json:"SubmittingPBUID"`
	SecurityId           string `json:"SecurityID"`
	SecurityIdsource     string `json:"SecurityIDSource"`
	RefSeqNum            int64  `json:"RefSeqNum"`
	RefMsgType           uint32 `json:"RefMsgType"`
	BusinessRejectRefId  string `json:"BusinessRejectRefID"`
	BusinessRejectReason uint16 `json:"BusinessRejectReason"`
	BusinessRejectText   string `json:"BusinessRejectText"`
}

// NewBusinessReject creates a new instance of BusinessReject.
func NewBusinessReject() *BusinessReject {
	return &BusinessReject{}
}

// String returns a string representation of the packet.
func (p *BusinessReject) String() string {
	return fmt.Sprintf("BusinessReject{ApplId: %v, TransactTime: %v, SubmittingPbuid: %v, SecurityId: %v, SecurityIdsource: %v, RefSeqNum: %v, RefMsgType: %v, BusinessRejectRefId: %v, BusinessRejectReason: %v, BusinessRejectText: %v}", p.ApplId, p.TransactTime, p.SubmittingPbuid, p.SecurityId, p.SecurityIdsource, p.RefSeqNum, p.RefMsgType, p.BusinessRejectRefId, p.BusinessRejectReason, p.BusinessRejectText)
}

// Encode encodes the packet into a byte slice.
func (p *BusinessReject) Encode(buf *bytes.Buffer) error {
	// Implement encoding logic here.
	if err := codec.PutFixedString(buf, p.ApplId, 3); err != nil {
		return err
	}
	if err := codec.PutBasicType(buf, p.TransactTime); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "TransactTime", err)
	}
	if err := codec.PutFixedString(buf, p.SubmittingPbuid, 6); err != nil {
		return err
	}
	if err := codec.PutFixedString(buf, p.SecurityId, 8); err != nil {
		return err
	}
	if err := codec.PutFixedString(buf, p.SecurityIdsource, 4); err != nil {
		return err
	}
	if err := codec.PutBasicType(buf, p.RefSeqNum); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "RefSeqNum", err)
	}
	if err := codec.PutBasicType(buf, p.RefMsgType); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "RefMsgType", err)
	}
	if err := codec.PutFixedString(buf, p.BusinessRejectRefId, 10); err != nil {
		return err
	}
	if err := codec.PutBasicType(buf, p.BusinessRejectReason); err != nil {
		return fmt.Errorf("failed to encode %s: %w", "BusinessRejectReason", err)
	}
	if err := codec.PutFixedString(buf, p.BusinessRejectText, 50); err != nil {
		return err
	}
	return nil
}

// Decode decodes the packet from a byte slice.
func (p *BusinessReject) Decode(buf *bytes.Buffer) error {
	if val, err := codec.GetFixedString(buf, 3); err != nil {
		return err
	} else {
		p.ApplId = val
	}
	if val, err := codec.GetBasicType[int64](buf); err != nil {
		return err
	} else {
		p.TransactTime = val
	}
	if val, err := codec.GetFixedString(buf, 6); err != nil {
		return err
	} else {
		p.SubmittingPbuid = val
	}
	if val, err := codec.GetFixedString(buf, 8); err != nil {
		return err
	} else {
		p.SecurityId = val
	}
	if val, err := codec.GetFixedString(buf, 4); err != nil {
		return err
	} else {
		p.SecurityIdsource = val
	}
	if val, err := codec.GetBasicType[int64](buf); err != nil {
		return err
	} else {
		p.RefSeqNum = val
	}
	if val, err := codec.GetBasicType[uint32](buf); err != nil {
		return err
	} else {
		p.RefMsgType = val
	}
	if val, err := codec.GetFixedString(buf, 10); err != nil {
		return err
	} else {
		p.BusinessRejectRefId = val
	}
	if val, err := codec.GetBasicType[uint16](buf); err != nil {
		return err
	} else {
		p.BusinessRejectReason = val
	}
	if val, err := codec.GetFixedString(buf, 50); err != nil {
		return err
	} else {
		p.BusinessRejectText = val
	}
	return nil
}
